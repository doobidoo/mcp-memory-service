{
  "id": "snapshot_1767100085184_6nk4z38eh",
  "approvalId": "approval_1767100085182_m19qxkd20",
  "approvalTitle": "design.md - Codebase Remediation Design",
  "version": 1,
  "timestamp": "2025-12-30T13:08:05.184Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Codebase Remediation\n\n## Overview\n\nThis design transforms a 34,233-line monolithic codebase into a ~2,000-line hexagonal architecture. The core principle: **service.py is the heart** - pure business logic that knows nothing about protocols or storage implementations.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Python 3.13+ with strict type checking (basedpyright)\n- FastMCP for MCP protocol, FastAPI for HTTP (optional)\n- pydantic-settings for configuration with SecretStr for secrets\n- Qdrant for production, SQLite-vec for development\n- e5-base-v2 embeddings (768-dim, no prefix complexity)\n\n### Project Structure (structure.md)\n```\nsrc/mcp_memory_service/\n├── __init__.py            # Version, quick imports\n├── config.py              # 4 Settings classes (~200 lines)\n├── memory.py              # Memory dataclass (~50 lines)\n├── service.py             # MemoryService - THE CORE (~300 lines)\n├── storage/\n│   ├── __init__.py        # BaseStorage Protocol + factory (~100 lines)\n│   ├── qdrant.py          # Production adapter (~600 lines)\n│   └── sqlite.py          # Dev adapter (~400 lines)\n├── api/\n│   ├── __init__.py\n│   ├── mcp.py             # FastMCP tools + TOON (~400 lines)\n│   └── http.py            # FastAPI routes (~300 lines)\n└── main.py                # Bootstrap, DI, lifecycle (~150 lines)\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **Qdrant storage logic**: Core upsert/search/delete from existing `storage/qdrant.py`\n- **SQLite-vec storage**: Vector operations from existing `storage/sqlite.py`\n- **Embedding generation**: `sentence-transformers` model loading from current implementation\n- **TOON formatting**: Existing pipe-delimited format from MCP tools\n\n### Integration Points\n- **FastMCP**: Direct integration via `@mcp.tool()` decorators\n- **Qdrant Client**: `qdrant-client` async operations\n- **SQLite-vec**: `sqlite3` with `sqlite-vec` extension\n\n## Architecture\n\nThe hexagonal (ports & adapters) architecture isolates business logic from infrastructure:\n\n```mermaid\ngraph TD\n    subgraph \"Protocol Adapters (api/)\"\n        MCP[api/mcp.py<br/>FastMCP Tools]\n        HTTP[api/http.py<br/>FastAPI Routes]\n    end\n\n    subgraph \"Core Domain\"\n        SVC[service.py<br/>MemoryService]\n        MEM[memory.py<br/>Memory Dataclass]\n    end\n\n    subgraph \"Storage Adapters (storage/)\"\n        PROTO[__init__.py<br/>BaseStorage Protocol]\n        QD[qdrant.py<br/>QdrantStorage]\n        SQL[sqlite.py<br/>SqliteStorage]\n    end\n\n    subgraph \"Configuration\"\n        CFG[config.py<br/>Settings Classes]\n    end\n\n    MCP --> SVC\n    HTTP --> SVC\n    SVC --> MEM\n    SVC --> PROTO\n    PROTO --> QD\n    PROTO --> SQL\n    SVC --> CFG\n    QD --> CFG\n    SQL --> CFG\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: `service.py` = business logic only, `api/mcp.py` = protocol translation only\n- **Component Isolation**: Storage backends are interchangeable via Protocol\n- **Service Layer Separation**: API layer never touches storage directly\n- **Utility Modularity**: TOON formatting lives in `api/mcp.py` (only consumer)\n\n## Components and Interfaces\n\n### Component 1: MemoryService (service.py)\n- **Purpose:** Core business logic for memory operations\n- **Interfaces:**\n  ```python\n  class MemoryService:\n      async def store(self, content: str, tags: list[str] | None = None,\n                      memory_type: str = \"note\", metadata: dict | None = None) -> Memory\n      async def retrieve(self, query: str, limit: int = 10,\n                         min_similarity: float = 0.6) -> list[tuple[Memory, float]]\n      async def search_by_tag(self, tags: list[str], match_all: bool = False,\n                              limit: int = 10) -> list[Memory]\n      async def list_memories(self, limit: int = 10, offset: int = 0,\n                              tag: str | None = None) -> list[Memory]\n      async def delete(self, content_hash: str) -> bool\n      async def health_check(self) -> dict\n  ```\n- **Dependencies:** BaseStorage (interface), EmbeddingModel\n- **Reuses:** Embedding logic from current implementation\n\n### Component 2: BaseStorage Protocol (storage/__init__.py)\n- **Purpose:** Define storage contract for all backends\n- **Interfaces:**\n  ```python\n  class BaseStorage(Protocol):\n      async def upsert(self, memory: Memory, embedding: list[float]) -> None\n      async def search(self, embedding: list[float], limit: int,\n                       min_score: float) -> list[tuple[Memory, float]]\n      async def search_by_tags(self, tags: list[str], match_all: bool,\n                               limit: int) -> list[Memory]\n      async def list(self, limit: int, offset: int, tag: str | None) -> list[Memory]\n      async def delete(self, content_hash: str) -> bool\n      async def count(self) -> int\n      async def health(self) -> dict\n  ```\n- **Dependencies:** None (pure interface)\n- **Reuses:** Contract patterns from existing storage implementations\n\n### Component 3: QdrantStorage (storage/qdrant.py)\n- **Purpose:** Production storage using Qdrant vector database\n- **Interfaces:** Implements BaseStorage Protocol\n- **Dependencies:** `qdrant-client`, QdrantSettings\n- **Reuses:** Core Qdrant operations from existing implementation\n\n### Component 4: SqliteStorage (storage/sqlite.py)\n- **Purpose:** Development storage using SQLite with vector extension\n- **Interfaces:** Implements BaseStorage Protocol\n- **Dependencies:** `sqlite3`, `sqlite-vec`, SqliteSettings\n- **Reuses:** SQLite vector operations from existing implementation\n\n### Component 5: MCP Tools (api/mcp.py)\n- **Purpose:** Expose MemoryService via MCP protocol\n- **Interfaces:**\n  ```python\n  @mcp.tool()\n  async def store_memory(content: str, tags: list[str] | None = None, ...) -> dict\n\n  @mcp.tool()\n  async def retrieve_memory(query: str, limit: int = 10, ...) -> str  # TOON format\n\n  @mcp.tool()\n  async def search_by_tag(tags: list[str], match_all: bool = False, ...) -> str\n\n  @mcp.tool()\n  async def list_memories(limit: int = 10, ...) -> str\n\n  @mcp.tool()\n  async def delete_memory(content_hash: str) -> dict\n\n  @mcp.tool()\n  async def check_database_health() -> dict\n  ```\n- **Dependencies:** MemoryService, FastMCP\n- **Reuses:** TOON formatting from existing MCP implementation\n\n### Component 6: HTTP API (api/http.py)\n- **Purpose:** Optional REST API for web dashboard\n- **Interfaces:** FastAPI routes mirroring MCP tools\n- **Dependencies:** MemoryService, FastAPI\n- **Reuses:** Route patterns from existing HTTP implementation\n\n## Data Models\n\n### Memory (memory.py)\n```python\n@dataclass\nclass Memory:\n    content: str                          # The stored text\n    content_hash: str                     # SHA256 hash for deduplication\n    tags: list[str]                       # Categorization labels\n    memory_type: str                      # \"note\" | \"decision\" | \"task\" | \"reference\"\n    metadata: dict[str, Any] | None       # Additional structured data\n    created_at: datetime                  # UTC timestamp\n    updated_at: datetime                  # UTC timestamp\n```\n\n### Configuration Classes (config.py)\n```python\nclass CoreSettings(BaseSettings):\n    storage_backend: Literal[\"qdrant\", \"sqlite\"] = \"qdrant\"\n    embedding_model: str = \"intfloat/e5-base-v2\"\n    embedding_dim: int = 768\n    log_level: str = \"INFO\"\n\nclass QdrantSettings(BaseSettings):\n    host: str = \"localhost\"\n    port: int = 6333\n    collection_name: str = \"memories\"\n    api_key: SecretStr | None = None\n\nclass SqliteSettings(BaseSettings):\n    db_path: Path = Path(\"memories.db\")\n\nclass ApiSettings(BaseSettings):\n    http_enabled: bool = False\n    http_port: int = 8080\n    cors_origins: list[str] = []  # Default empty, NOT ['*']\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Storage Connection Failure**\n   - **Handling:** Raise `StorageConnectionError` with connection details\n   - **User Impact:** MCP tool returns error with actionable message\n\n2. **Embedding Model Load Failure**\n   - **Handling:** Fail startup loudly with clear error message\n   - **User Impact:** Service won't start, logs show exact issue\n\n3. **Invalid Content Hash on Delete**\n   - **Handling:** Return `{\"success\": false, \"message\": \"Memory not found\"}`\n   - **User Impact:** Clear feedback, no silent failure\n\n4. **Duplicate Content Storage**\n   - **Handling:** Upsert (update existing memory with same hash)\n   - **User Impact:** Memory updated, not duplicated\n\n5. **Configuration Validation Failure**\n   - **Handling:** pydantic raises ValidationError at startup\n   - **User Impact:** Service won't start, exact missing/invalid config shown\n\n## Testing Strategy\n\n### Unit Testing\n- **service.py**: Mock storage, test all business logic paths\n- **config.py**: Test validation rules, defaults, SecretStr handling\n- **memory.py**: Test dataclass creation, hash generation\n\n### Integration Testing\n- **storage/qdrant.py**: Test against real Qdrant (Docker in CI)\n- **storage/sqlite.py**: Test with in-memory SQLite\n- **api/mcp.py**: Test tool registration and TOON formatting\n\n### End-to-End Testing\n- Store → Retrieve → Delete flow via MCP\n- Tag search with various AND/OR combinations\n- Health check under normal and degraded conditions\n\n## Deletion Strategy\n\n### Phase 0: Security Fixes (Immediate)\n- Delete `authlib`, `python-jose` from dependencies\n- Fix anonymous access → read-only\n- Fix CORS default → empty `[]`\n- Delete mDNS discovery code\n\n### Phase 1: Dead Code Removal\nFiles to delete entirely:\n- `server.py`, `mcp_server.py`, `unified_server.py`\n- `lm_studio_compat.py`\n- `consolidation/`, `discovery/`, `sync/`, `ingestion/`\n- `embeddings/onnx_*.py`\n- `web/oauth/`\n\n### Phase 2: Storage Consolidation\nFiles to delete:\n- `storage/cloudflare.py`\n- `storage/hybrid.py`\n- `storage/http_client.py`\n\n### Phase 3: Config Collapse\n- Merge 15 config classes → 4 (Core, Qdrant, SQLite, Api)\n- Delete all unused configuration options\n\n## Migration Safety\n\n- **Data Preservation**: All Qdrant data remains untouched\n- **Rollback Path**: Keep old code in git history\n- **Validation**: Run test suite after each deletion phase\n- **Gradual Transition**: Phase-by-phase with verification\n",
  "fileStats": {
    "size": 10264,
    "lines": 282,
    "lastModified": "2025-12-30T13:07:56.611Z"
  },
  "comments": []
}
