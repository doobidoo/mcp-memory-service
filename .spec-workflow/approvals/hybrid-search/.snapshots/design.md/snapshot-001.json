{
  "id": "snapshot_1769301082677_8j5sc48pj",
  "approvalId": "approval_1769301082674_npwdro8xt",
  "approvalTitle": "Hybrid Search Design Document",
  "version": 1,
  "timestamp": "2026-01-25T00:31:22.677Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Hybrid Search\n\n## Overview\n\nHybrid search combines vector similarity (semantic meaning) with keyword/tag matching to improve retrieval precision. This addresses documented failure cases where pure vector search returns semantically similar but categorically unrelated memories (e.g., searching \"rathole project architecture\" returns Cachekit memories instead of Rathole tunnel setup).\n\nThe feature is **enabled by default** with zero configuration required. Users get better search results immediately. Legacy pure-vector behavior is available via opt-out (`MCP_MEMORY_HYBRID_ALPHA=1.0`).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Pydantic Settings**: New hybrid configuration uses `HybridSearchSettings` class following existing patterns in `config.py`\n- **Environment Variables**: All settings follow `MCP_MEMORY_` prefix convention\n- **SecretStr**: N/A - no sensitive configuration for hybrid search\n- **Type Safety**: All new code includes type hints validated by basedpyright\n\n### Project Structure (structure.md)\n\n- **Service Layer**: Hybrid scoring logic lives in `MemoryService`, not storage backends\n- **Pure Functions**: RRF and keyword extraction are utility functions in dedicated module\n- **No New Files for Config**: Settings added to existing `config.py`\n- **Test Colocation**: Evaluation harness in `tests/eval/` following existing test structure\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n| Component | Location | Usage |\n|-----------|----------|-------|\n| `MemoryService.retrieve_memories()` | `services/memory_service.py:258` | Modify to orchestrate hybrid search |\n| `storage.retrieve()` | `storage/base.py:95` | Vector search (unchanged) |\n| `storage.search_by_tag()` | `storage/base.py:121` | Tag search for boosting |\n| `storage.get_all_tags()` | `storage/base.py:296` | Validate extracted keywords |\n| `storage.count_all_memories()` | `storage/base.py:345` | Corpus size for adaptive alpha |\n| `_build_pagination_metadata()` | `services/memory_service.py:52` | Pagination (unchanged) |\n\n### Integration Points\n\n- **Storage Backends**: No changes required. Hybrid scoring is composed at service layer.\n- **MCP Tools**: `retrieve_memory` tool delegates to `MemoryService.retrieve_memories()` - no changes needed.\n- **Config System**: New `HybridSearchSettings` nested in main `Settings` class.\n\n## Architecture\n\nHybrid search is implemented as a **composition pattern** at the service layer, combining results from existing vector and tag search methods.\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                      MCP Tool Layer                         │\n│                   (mcp_server.py - unchanged)               │\n└─────────────────────────────┬───────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                    MemoryService Layer                      │\n│                                                             │\n│  retrieve_memories()                                        │\n│    ├── get_adaptive_alpha()    ← NEW: corpus-based alpha    │\n│    ├── extract_query_keywords() ← NEW: tag extraction       │\n│    ├── storage.retrieve()       (vector search)             │\n│    ├── storage.search_by_tag()  (tag boost candidates)      │\n│    ├── rrf_combine()           ← NEW: score fusion          │\n│    └── apply_recency_decay()   ← NEW: recency multiplier    │\n│                                                             │\n└─────────────────────────────┬───────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                    Storage Layer                            │\n│              (SQLite-vec / Qdrant - unchanged)              │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Data Flow\n\n```\nQuery: \"rathole project codebase architecture\"\n                    │\n                    ▼\n┌───────────────────────────────────────┐\n│ 1. Extract Keywords                   │\n│    [\"rathole\", \"project\", \"codebase\", │\n│     \"architecture\"]                   │\n└───────────────────┬───────────────────┘\n                    │\n        ┌───────────┴───────────┐\n        ▼                       ▼\n┌───────────────┐       ┌───────────────┐\n│ Vector Search │       │ Tag Matching  │\n│ (semantic)    │       │ (exact match) │\n│               │       │               │\n│ Returns:      │       │ Matches:      │\n│ - Cachekit    │       │ - rathole     │\n│ - Litesearch  │       │ - project     │\n│ - Rathole     │       │               │\n└───────┬───────┘       └───────┬───────┘\n        │                       │\n        └───────────┬───────────┘\n                    ▼\n┌───────────────────────────────────────┐\n│ 2. RRF Combination                    │\n│    score = α × vec_rrf +              │\n│            (1-α) × tag_rrf            │\n│                                       │\n│    Rathole: 0.033 + 0.016 = high      │\n│    Cachekit: 0.033 + 0 = lower        │\n└───────────────────┬───────────────────┘\n                    │\n                    ▼\n┌───────────────────────────────────────┐\n│ 3. Recency Decay (optional)           │\n│    final = score × e^(-decay × days)  │\n└───────────────────┬───────────────────┘\n                    │\n                    ▼\n        [Rathole, Cachekit, Litesearch]\n                (reranked)\n```\n\n## Components and Interfaces\n\n### Component 1: HybridSearchSettings\n\n**Purpose:** Configuration for hybrid search parameters\n\n**Location:** `src/mcp_memory_service/config.py` (add to existing file)\n\n**Interface:**\n```python\nclass HybridSearchSettings(BaseSettings):\n    \"\"\"Hybrid search configuration.\"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix='MCP_MEMORY_',\n        env_file='.env',\n        extra='ignore'\n    )\n\n    # Core hybrid parameters\n    hybrid_alpha: Optional[float] = Field(\n        default=None,  # None = adaptive mode\n        ge=0.0, le=1.0,\n        description=\"Vector vs tag balance (0=tags, 1=vector, None=adaptive)\"\n    )\n\n    # Recency decay\n    recency_decay: float = Field(\n        default=0.01,  # Half-life ~70 days\n        ge=0.0,\n        description=\"Recency decay rate (0=disabled)\"\n    )\n\n    # Adaptive thresholds (corpus size boundaries)\n    adaptive_threshold_small: int = Field(default=500)\n    adaptive_threshold_large: int = Field(default=5000)\n```\n\n**Dependencies:** pydantic-settings (existing)\n\n### Component 2: Keyword Extraction Utility\n\n**Purpose:** Extract potential tag keywords from query string\n\n**Location:** `src/mcp_memory_service/utils/hybrid_search.py` (new file)\n\n**Interface:**\n```python\n# Stop words for English (common words to exclude)\nSTOP_WORDS: frozenset[str]\n\ndef extract_query_keywords(\n    query: str,\n    existing_tags: Optional[set[str]] = None\n) -> list[str]:\n    \"\"\"\n    Extract potential tag keywords from a search query.\n\n    Args:\n        query: User's search query\n        existing_tags: Set of tags that exist in database (for validation)\n\n    Returns:\n        List of normalized keywords that may match tags\n\n    Algorithm:\n        1. Lowercase and tokenize (split on whitespace/punctuation)\n        2. Remove stop words\n        3. If existing_tags provided, filter to only matching tags\n        4. Return unique keywords\n    \"\"\"\n```\n\n**Dependencies:** None (pure Python, no external deps)\n\n### Component 3: RRF Combination Utility\n\n**Purpose:** Combine ranked results using Reciprocal Rank Fusion\n\n**Location:** `src/mcp_memory_service/utils/hybrid_search.py`\n\n**Interface:**\n```python\ndef rrf_score(rank: int, k: int = 60) -> float:\n    \"\"\"\n    Calculate Reciprocal Rank Fusion score.\n\n    Args:\n        rank: Position in ranked list (1-indexed)\n        k: Smoothing constant (default 60, standard in literature)\n\n    Returns:\n        RRF score: 1 / (k + rank)\n    \"\"\"\n\ndef combine_results_rrf(\n    vector_results: list[MemoryQueryResult],\n    tag_matches: list[Memory],\n    alpha: float,\n    k: int = 60\n) -> list[tuple[Memory, float, dict]]:\n    \"\"\"\n    Combine vector search and tag search results using RRF.\n\n    Args:\n        vector_results: Ranked results from semantic search (with similarity scores)\n        tag_matches: Memories matching extracted tags\n        alpha: Weight for vector results (1-alpha for tags)\n        k: RRF smoothing constant\n\n    Returns:\n        List of (memory, combined_score, debug_info) tuples\n        Debug info includes vector_score, tag_boost, rrf breakdown\n    \"\"\"\n```\n\n**Dependencies:** None (pure function)\n\n### Component 4: Adaptive Alpha Calculator\n\n**Purpose:** Determine optimal alpha based on corpus characteristics\n\n**Location:** `src/mcp_memory_service/utils/hybrid_search.py`\n\n**Interface:**\n```python\ndef get_adaptive_alpha(\n    corpus_size: int,\n    matching_tag_count: int,\n    config: HybridSearchSettings\n) -> float:\n    \"\"\"\n    Calculate adaptive alpha based on corpus size and query characteristics.\n\n    Research basis: RecSys crossover experiments show algorithm effectiveness\n    varies by scale - exact match outperforms ML at small scale.\n\n    Args:\n        corpus_size: Total memories in database\n        matching_tag_count: How many query terms match existing tags\n        config: Hybrid search settings with thresholds\n\n    Returns:\n        Alpha value (0.0-1.0)\n\n    Logic:\n        - corpus < 500: alpha = 0.5 (balanced)\n        - 500 <= corpus < 5000: alpha = 0.7 (semantic-biased)\n        - corpus >= 5000: alpha = 0.8 (strong semantic)\n        - If matching_tag_count >= 3: boost tag weight by 1.5x\n    \"\"\"\n```\n\n### Component 5: Modified MemoryService.retrieve_memories()\n\n**Purpose:** Orchestrate hybrid search pipeline\n\n**Location:** `src/mcp_memory_service/services/memory_service.py` (modify existing)\n\n**Interface:** No change to public interface - backward compatible\n\n**Internal Changes:**\n```python\nasync def retrieve_memories(\n    self,\n    query: str,\n    page: int = 1,\n    page_size: int = 10,\n    tags: Optional[List[str]] = None,  # Explicit tags (override extraction)\n    memory_type: Optional[str] = None,\n    min_similarity: Optional[float] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Retrieve memories using hybrid search (vector + tag matching).\n\n    Hybrid search is enabled by default. To disable:\n    - Set MCP_MEMORY_HYBRID_ALPHA=1.0 for pure vector search\n    - Pass tags=[] to skip automatic tag extraction\n    \"\"\"\n    # NEW: Get hybrid config\n    config = get_hybrid_settings()\n\n    # NEW: Determine alpha (explicit, env, or adaptive)\n    if config.hybrid_alpha is not None:\n        alpha = config.hybrid_alpha\n    else:\n        corpus_size = await self.storage.count_all_memories()\n        extracted_keywords = extract_query_keywords(query)\n        all_tags = await self.storage.get_all_tags()\n        matching_tags = [k for k in extracted_keywords if k in all_tags]\n        alpha = get_adaptive_alpha(corpus_size, len(matching_tags), config)\n\n    # If alpha == 1.0, skip hybrid (pure vector)\n    if alpha >= 1.0:\n        return await self._retrieve_vector_only(...)  # Existing logic\n\n    # NEW: Parallel fetch vector and tag results\n    vector_results, tag_matches = await asyncio.gather(\n        self.storage.retrieve(query, n_results=page_size * 2, ...),\n        self._get_tag_boost_candidates(query, matching_tags)\n    )\n\n    # NEW: Combine with RRF\n    combined = combine_results_rrf(vector_results, tag_matches, alpha)\n\n    # NEW: Apply recency decay if enabled\n    if config.recency_decay > 0:\n        combined = apply_recency_decay(combined, config.recency_decay)\n\n    # Paginate and format results (existing logic)\n    ...\n```\n\n**Dependencies:**\n- `utils/hybrid_search.py` (new)\n- `config.HybridSearchSettings` (new)\n\n## Data Models\n\n### Debug Info Extension (Optional)\n\nWhen debug info is requested, results include score breakdown:\n\n```python\nclass HybridScoreDebug(TypedDict):\n    \"\"\"Debug information for hybrid scoring.\"\"\"\n    vector_score: float      # Raw cosine similarity from vector search\n    vector_rank: int         # Position in vector results\n    vector_rrf: float        # RRF contribution from vector\n    tag_boost: float         # Contribution from tag matching\n    tag_matches: list[str]   # Which tags matched\n    recency_factor: float    # Multiplier applied for freshness\n    final_score: float       # Combined hybrid score\n    alpha_used: float        # Alpha value used (for debugging adaptive)\n```\n\nThis is **not** a new database model - it's metadata attached to search results when debugging.\n\n## Error Handling\n\n### Error Scenario 1: Tag Extraction Fails\n\n**Handling:** Fall back to pure vector search. Log warning but don't fail request.\n\n**User Impact:** Slightly degraded results (pure semantic) but no error visible.\n\n```python\ntry:\n    extracted_keywords = extract_query_keywords(query)\nexcept Exception as e:\n    logger.warning(f\"Tag extraction failed, falling back to vector: {e}\")\n    extracted_keywords = []\n```\n\n### Error Scenario 2: get_all_tags() Times Out\n\n**Handling:** Skip tag validation, use extracted keywords directly. Cache tags if possible.\n\n**User Impact:** May match against non-existent tags (no boost applied anyway).\n\n### Error Scenario 3: Corpus Count Unavailable\n\n**Handling:** Default to balanced alpha (0.5) if corpus size cannot be determined.\n\n**User Impact:** May not get optimal alpha, but search still works.\n\n```python\ntry:\n    corpus_size = await self.storage.count_all_memories()\nexcept Exception:\n    corpus_size = 0  # Will trigger balanced alpha\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Location:** `tests/unit/test_hybrid_search.py`\n\n| Test Case | Description |\n|-----------|-------------|\n| `test_rrf_score_basic` | Verify RRF formula: rank 1 → 0.0164 |\n| `test_rrf_score_edge_cases` | Rank 0, negative rank, large rank |\n| `test_extract_keywords_basic` | \"rathole project\" → [\"rathole\", \"project\"] |\n| `test_extract_keywords_stop_words` | \"the quick brown fox\" → [\"quick\", \"brown\", \"fox\"] |\n| `test_extract_keywords_punctuation` | \"python,api,bug-fix\" → [\"python\", \"api\", \"bug\", \"fix\"] |\n| `test_combine_results_rrf_alpha_1` | Pure vector (no tag boost) |\n| `test_combine_results_rrf_alpha_0` | Pure tag matching |\n| `test_combine_results_rrf_overlap` | Same memory in both lists |\n| `test_adaptive_alpha_small_corpus` | <500 → 0.5 |\n| `test_adaptive_alpha_large_corpus` | >5000 → 0.8 |\n| `test_adaptive_alpha_tag_boost` | 3+ tag matches → weight boost |\n| `test_recency_decay_basic` | 70 days old → ~0.5x multiplier |\n| `test_recency_decay_disabled` | decay=0 → no change |\n\n### Integration Testing\n\n**Location:** `tests/integration/test_hybrid_retrieve.py`\n\n| Test Case | Description |\n|-----------|-------------|\n| `test_hybrid_enabled_by_default` | Default behavior uses hybrid |\n| `test_opt_out_pure_vector` | `HYBRID_ALPHA=1.0` → pure vector |\n| `test_tag_extraction_boosts_results` | Query with matching tag ranks higher |\n| `test_backward_compatibility` | Existing API unchanged |\n| `test_pagination_with_hybrid` | Page 2 works correctly |\n\n### Evaluation Harness\n\n**Location:** `tests/eval/`\n\n```\ntests/eval/\n├── __init__.py\n├── conftest.py           # Shared fixtures, ground truth loader\n├── ground_truth.json     # Query → expected_memory_hash pairs\n├── test_hit_rate.py      # Hit Rate@10 evaluation\n├── test_mrr.py           # Mean Reciprocal Rank evaluation\n├── test_ndcg.py          # NDCG@10 evaluation\n└── sweep_alpha.py        # Alpha grid search script\n```\n\n**Ground Truth Format:**\n```json\n{\n  \"test_cases\": [\n    {\n      \"query\": \"rathole project codebase architecture\",\n      \"expected_hashes\": [\"abc123...\"],\n      \"expected_tags\": [\"rathole\", \"project\"],\n      \"category\": \"tag_sensitive\"\n    }\n  ]\n}\n```\n\n**Running Evaluation:**\n```bash\n# Run all eval tests\npytest tests/eval/ -v\n\n# Grid search alpha values\npython tests/eval/sweep_alpha.py\n\n# Output:\n# Alpha | Hit@10 | MRR    | NDCG@10\n# 0.3   | 0.72   | 0.65   | 0.68\n# 0.5   | 0.82   | 0.71   | 0.74\n# 0.7   | 0.85   | 0.73   | 0.76  ← Optimal\n# 1.0   | 0.62   | 0.58   | 0.61\n```\n\n**Dependencies:** `ranx` (add to dev dependencies in pyproject.toml)\n\n## Non-Functional Considerations\n\n### Performance\n\n- **Latency target:** <120ms p95 (vs ~50ms for pure vector)\n- **Mitigation:** Parallel fetch vector + tag results with `asyncio.gather`\n- **No additional storage queries:** Reuse existing `retrieve()` and `search_by_tag()`\n\n### Code Size\n\n- **Feature code:** Target <200 lines (service layer + utils)\n- **Eval harness:** Target <150 lines\n- **Config changes:** ~30 lines (HybridSearchSettings)\n\n### Backward Compatibility\n\n- **API unchanged:** `retrieve_memory` tool signature unchanged\n- **Results improved:** Same inputs, better outputs (hybrid active by default)\n- **Opt-out available:** `MCP_MEMORY_HYBRID_ALPHA=1.0` for legacy behavior\n\n## Implementation Order\n\n1. **Config** - Add `HybridSearchSettings` to config.py\n2. **Utils** - Create `utils/hybrid_search.py` with pure functions\n3. **Unit Tests** - Write tests for RRF, keyword extraction, adaptive alpha\n4. **Service Layer** - Modify `retrieve_memories()` to use hybrid pipeline\n5. **Integration Tests** - Test end-to-end hybrid behavior\n6. **Evaluation Harness** - Build ground truth and metrics infrastructure\n7. **Tuning** - Run alpha sweep, set optimal defaults based on data\n\n## Open Questions (Resolved)\n\n| Question | Resolution |\n|----------|------------|\n| Use Qdrant native hybrid? | No - requires sparse vectors (schema change). Application-level RRF is simpler. |\n| Cache get_all_tags()? | Yes - cache for 60s, tags change infrequently. |\n| Store debug info where? | In-memory only (not persisted). Return in response when requested. |\n",
  "fileStats": {
    "size": 19556,
    "lines": 512,
    "lastModified": "2026-01-25T00:31:13.916Z"
  },
  "comments": []
}
