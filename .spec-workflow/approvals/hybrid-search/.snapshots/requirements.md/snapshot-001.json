{
  "id": "snapshot_1769299321883_bztuow88w",
  "approvalId": "approval_1769299321876_0cwgds9y9",
  "approvalTitle": "Hybrid Search Requirements",
  "version": 1,
  "timestamp": "2026-01-25T00:02:01.883Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: Hybrid Search\n\n## Introduction\n\nHybrid search combines vector similarity (semantic meaning) with keyword/tag matching to improve retrieval precision when pure semantic search fails. This addresses a documented failure case where searching for \"rathole project codebase architecture\" returned Cachekit and Litesearch memories instead of Rathole tunnel setup memories — semantically distant but categorically identical (same project).\n\n**Value Proposition**: Improve search recall from ~60% to ~85%+ for queries where project names, technical terms, or categorical tags matter as much as semantic meaning.\n\n## Alignment with Product Vision\n\nFrom `product.md`:\n- **Core Feature #2**: \"Semantic Retrieval: Find memories by meaning using cosine similarity\"\n- **Core Feature #3**: \"Tag-Based Search: Categorical filtering with AND/OR logic\"\n\nHybrid search unifies these capabilities into a single, smarter retrieval operation. It aligns with:\n- **KISS Principle**: Single method instead of users manually combining search strategies\n- **V2 Vision**: \"Memory Graph Matching\" — hybrid search is a stepping stone to relationship-aware retrieval\n\n## Requirements\n\n### Requirement 1: Unified Hybrid Retrieval\n\n**User Story:** As an AI assistant using MCP memory, I want a single search operation that considers both semantic meaning AND exact keyword/tag matches, so that I don't miss relevant memories that are semantically distant but categorically related.\n\n#### Acceptance Criteria\n\n1. WHEN `retrieve_memory` is called with a query THEN the system SHALL return results ranked by a hybrid score combining:\n   - Vector similarity (semantic match)\n   - Tag relevance boost (if query terms match existing tags)\n\n2. IF the query contains terms that exactly match memory tags THEN those memories SHALL receive a score boost regardless of vector similarity.\n\n3. WHEN results from vector search and tag-boosted search overlap THEN the system SHALL use Reciprocal Rank Fusion (RRF) to combine scores fairly.\n\n4. WHEN `min_similarity` threshold is provided THEN it SHALL apply to the final hybrid score, not just vector similarity.\n\n### Requirement 2: Automatic Tag Extraction from Queries\n\n**User Story:** As an AI assistant, I want the system to automatically detect potential tag keywords in my query, so that I don't need to manually specify both a query string and a tag filter.\n\n#### Acceptance Criteria\n\n1. WHEN a query is submitted THEN the system SHALL extract potential tag keywords using:\n   - Word tokenization (split on whitespace/punctuation)\n   - Stop word removal (common words like \"the\", \"is\", \"for\")\n   - Optional: project name detection (if a word matches an existing tag)\n\n2. IF extracted keywords match existing tags in the database THEN those tags SHALL be used for hybrid boosting.\n\n3. WHEN no keywords match existing tags THEN the system SHALL fall back to pure vector search (no degradation).\n\n### Requirement 3: Configurable Hybrid Balance\n\n**User Story:** As an administrator, I want to tune the balance between semantic and keyword matching, so that I can optimize for my specific use case (exploration vs. precision).\n\n#### Acceptance Criteria\n\n1. WHEN hybrid search is enabled THEN the system SHALL use a configurable alpha parameter:\n   - `alpha = 1.0`: Pure vector search (backward compatible default)\n   - `alpha = 0.5`: Balanced hybrid (recommended for most use cases)\n   - `alpha = 0.0`: Pure keyword/tag matching\n\n2. IF `alpha` is not specified THEN the system SHALL default to `0.7` (semantic-biased hybrid).\n\n3. WHEN the environment variable `MCP_MEMORY_HYBRID_ALPHA` is set THEN it SHALL override the default.\n\n### Requirement 4: Backward Compatibility\n\n**User Story:** As an existing user, I want hybrid search to be opt-in or seamlessly integrated, so that my existing workflows don't break.\n\n#### Acceptance Criteria\n\n1. WHEN `retrieve_memory` is called without explicit hybrid parameters THEN behavior SHALL match current pure vector search (alpha=1.0 default maintains compatibility).\n\n2. IF a user explicitly passes `tags=[]` filter THEN the system SHALL NOT apply automatic tag extraction.\n\n3. WHEN the tool schema is updated THEN existing tool calls SHALL continue to work without modification.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility**: Hybrid scoring logic lives in MemoryService layer, not storage backends\n- **Modular Design**: RRF function is a pure utility function, independently testable\n- **Clear Interfaces**: Storage backends continue to implement current interface; hybrid is composed at service layer\n- **Minimal Changes**: Target < 150 lines of new code (service layer only)\n\n### Performance\n\n- **Latency**: Hybrid search SHALL complete within 2x the latency of pure vector search\n- **No additional storage queries**: Use existing `retrieve()` and `search_by_tag()` methods; combine results in memory\n- **Memory efficiency**: RRF operates on result sets, not full corpus\n\n### Security\n\n- No new attack vectors (query extraction uses only existing tokenization)\n- No external API calls for keyword extraction\n- Tag matching uses existing sanitized tag storage\n\n### Reliability\n\n- **Graceful degradation**: If tag extraction fails, fall back to pure vector search\n- **No silent failures**: Log when hybrid mode activates vs. falls back\n- **Circuit breaker**: Inherit existing storage circuit breaker behavior\n\n### Usability\n\n- **Zero configuration required**: Works out of the box with sensible defaults\n- **Transparent scoring**: Debug info includes breakdown of vector vs. tag contribution\n- **Discoverable**: Tool description updated to explain hybrid capability\n\n## Out of Scope\n\n- Sparse vector indexing in Qdrant (future enhancement, requires schema migration)\n- BM25 full-text search (requires additional indexing infrastructure)\n- Query expansion / synonym matching (LLM feature, separate concern)\n- Multi-language keyword extraction (English only for MVP)\n\n## Success Metrics\n\n| Metric | Current | Target | Measurement |\n|--------|---------|--------|-------------|\n| Recall on tag-mismatch queries | ~60% | >85% | Test suite with known failures |\n| Search latency | 50ms | <100ms | p95 benchmark |\n| New code lines | 0 | <150 | LOC count |\n| Breaking changes | N/A | 0 | API compatibility test |\n\n## References\n\n- Memory: \"Memory Search Failure Case (2026-01-25)\" - documented failure that motivated this feature\n- Memory: \"Memory Search Protocol Update (2026-01-25)\" - workaround protocol that hybrid search replaces\n- Research: Hybrid search best practices 2026 (RRF, alpha tuning, BM25 patterns)\n- Qdrant docs: Native hybrid search via prefetch + FusionQuery (future path)\n",
  "fileStats": {
    "size": 6714,
    "lines": 134,
    "lastModified": "2026-01-25T00:01:55.967Z"
  },
  "comments": []
}
