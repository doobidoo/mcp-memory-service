# ============================================================================
# MCP Memory Service - Oracle Server Deployment Configuration
# ============================================================================
#
# This file contains all environment variables required for deploying
# MCP Memory Service to Oracle Cloud Infrastructure with Docker Compose.
#
# SETUP INSTRUCTIONS:
# 1. Copy this file to .env: cp .env.example .env
# 2. Fill in all values marked with <REQUIRED> or <GENERATE>
# 3. Keep this file secure - it contains sensitive credentials
# 4. Never commit .env to version control
#

# ============================================================================
# Network Configuration
# ============================================================================

# Tailscale IP address for HTTP server binding
# This is automatically populated by setup_tailscale.sh during deployment
# Format: 100.x.x.x (Tailscale CGNAT range)
# Security: Binding to Tailscale IP ensures no public internet exposure
TAILSCALE_IP=<AUTO_POPULATED_BY_SETUP_SCRIPT>

# ============================================================================
# MCP Memory Service Configuration
# ============================================================================

# Storage backend type
# For oracle-server deployment, always use sqlite_vec (local SQLite database)
# Other options (cloudflare, hybrid, http_client) are for different deployment scenarios
MCP_MEMORY_STORAGE_BACKEND=sqlite_vec

# SQLite database file path (inside container)
# Mapped to Docker volume "sqlite-data" for persistence across container restarts
# DO NOT CHANGE unless you modify docker-compose.yml volume mapping
MCP_MEMORY_SQLITE_DATABASE_PATH=/data/sqlite_vec.db

# SQLite performance and reliability settings
# busy_timeout=15000: Wait up to 15 seconds for locked database (prevents errors under concurrent load)
# journal_mode=WAL: Write-Ahead Logging for better concurrency and crash recovery
# synchronous=NORMAL: Balance between durability and performance (safe with WAL mode)
MCP_MEMORY_SQLITE_PRAGMAS=busy_timeout=15000,journal_mode=WAL,synchronous=NORMAL

# HTTP server configuration
# Enable HTTP server for client connections (required for oracle-server deployment)
MCP_HTTP_ENABLED=true

# API key for securing HTTP endpoints
# SECURITY: Generate a strong random key - NEVER use a weak password!
# Generate with: openssl rand -base64 32
# Clients must include this in Authorization header: "Authorization: Bearer <key>"
MCP_API_KEY=<GENERATE_WITH_OPENSSL_RAND>

# HTTPS configuration (optional, disabled by default)
# Enable HTTPS if you want encrypted connections over Tailscale
# Requires SSL certificate and key files
MCP_HTTPS_ENABLED=false
# MCP_SSL_CERT_FILE=/path/to/cert.pem
# MCP_SSL_KEY_FILE=/path/to/key.pem

# ============================================================================
# Backup Configuration (R2 / S3-compatible storage)
# ============================================================================

# Cloudflare R2 credentials for automated backups
# Create R2 bucket: https://dash.cloudflare.com/?to=/:account/r2
# Generate API token: https://dash.cloudflare.com/profile/api-tokens
#
# OPTIONAL: If you don't want automated backups, comment these out and
# remove the backup service from docker-compose.yml

# Cloudflare account ID
# Find at: https://dash.cloudflare.com/ → R2 → Overview
# Format: 32-character hexadecimal string
CLOUDFLARE_ACCOUNT_ID=<REQUIRED_FOR_BACKUPS>

# R2 Access Key ID
# Create in: R2 → Manage R2 API Tokens → Create API Token
# Permissions needed: Object Read & Write
R2_ACCESS_KEY_ID=<REQUIRED_FOR_BACKUPS>

# R2 Secret Access Key
# Generated when creating R2 API Token (shown once, save securely)
R2_SECRET_ACCESS_KEY=<REQUIRED_FOR_BACKUPS>

# R2 bucket name for backups
# Create bucket first in Cloudflare dashboard
# Naming: lowercase letters, numbers, hyphens only
R2_BUCKET_NAME=mcp-memory-backups

# R2 endpoint URL
# Format: https://<account-id>.r2.cloudflarestorage.com
# Replace <account-id> with your CLOUDFLARE_ACCOUNT_ID
R2_ENDPOINT=https://<CLOUDFLARE_ACCOUNT_ID>.r2.cloudflarestorage.com

# Backup schedule (cron format)
# Default: 0 */6 * * * (every 6 hours at minute 0)
# Examples:
#   - 0 */6 * * *   : Every 6 hours
#   - 0 2 * * *     : Daily at 2:00 AM
#   - 0 */12 * * *  : Twice daily (every 12 hours)
BACKUP_SCHEDULE=0 */6 * * *

# ============================================================================
# Docker Container Configuration
# ============================================================================

# Number of uvicorn worker processes
# Recommendation: Set to number of CPU cores (Oracle Free Tier: 4 cores)
# More workers = better concurrency, but higher memory usage
UVICORN_WORKERS=4

# Container resource limits (enforced by Docker Compose)
# These are set in docker-compose.yml and match Oracle Free Tier specs:
#   - mcp-memory: 3 CPUs, 16GB RAM (main service)
#   - backup: 1 CPU, 2GB RAM (backup sidecar)
#   - Total: 4 CPUs, 18GB RAM (leaves 6GB for OS)

# ============================================================================
# Migration Configuration (Optional)
# ============================================================================

# Cloudflare credentials for data migration from Cloudflare backend
# ONLY NEEDED if you're migrating existing memories from Cloudflare
# to this Oracle server deployment (one-time operation)
#
# If this is a fresh deployment, you can ignore these settings

# Cloudflare API token with D1 database access
# Create at: https://dash.cloudflare.com/profile/api-tokens
# Permissions: Account.D1 (Read), Account.Vectorize (Read)
# CLOUDFLARE_API_TOKEN=<REQUIRED_FOR_MIGRATION>

# Cloudflare D1 database ID (UUID format)
# Find at: https://dash.cloudflare.com/ → Workers & Pages → D1
# CLOUDFLARE_D1_DATABASE_ID=<REQUIRED_FOR_MIGRATION>

# Cloudflare Vectorize index name
# Default: mcp-memory-index (if you used standard setup)
# CLOUDFLARE_VECTORIZE_INDEX=mcp-memory-index

# ============================================================================
# Advanced Configuration (Usually no changes needed)
# ============================================================================

# Log level
# Options: DEBUG, INFO, WARNING, ERROR, CRITICAL
# Default: INFO (recommended for production)
LOG_LEVEL=INFO

# Enable debug tools in MCP interface
# WARNING: Debug tools expose raw database operations - disable in production
# Default: false (secure)
MCP_MEMORY_EXPOSE_DEBUG_TOOLS=false

# Document ingestion chunk size
# Size of text chunks when ingesting PDF/DOCX/etc documents
# Default: 1000 characters
MCP_DOCUMENT_CHUNK_SIZE=1000

# Document ingestion chunk overlap
# Overlap between chunks to preserve context across boundaries
# Default: 200 characters
MCP_DOCUMENT_CHUNK_OVERLAP=200

# ============================================================================
# End of Configuration
# ============================================================================
#
# After filling in all required values, save this file as .env
# Then run: docker compose up -d
#
# Verify configuration:
#   docker compose config   # Show parsed config
#   docker compose ps       # Check container status
#   curl http://$TAILSCALE_IP:8000/api/health  # Test HTTP endpoint
